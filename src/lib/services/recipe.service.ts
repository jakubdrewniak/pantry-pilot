import type { SupabaseClient } from '@supabase/supabase-js'
import type { Database } from '@/db/database.types'
import type { CreateRecipeInput, RecipeFilters } from '@/lib/validation/recipes'
import type { Recipe, Pagination, BulkDeleteRecipesResponse } from '@/types/types'

/**
 * Type alias for Supabase client with database types
 * Used for dependency injection in service layer
 */
type TypedSupabaseClient = SupabaseClient<Database>

/**
 * TEMPORARY: Default household ID for development
 * TODO: Remove this once household management is fully implemented.
 * For now, we have only one user in the database and need a mock household.
 */
const DEFAULT_HOUSEHOLD_ID = '00000000-0000-0000-0000-000000000001'

/**
 * Database representation of recipe content (JSONB column)
 * This matches the structure stored in the recipes.content column
 */
interface RecipeContent {
  title: string
  ingredients: Array<{
    name: string
    quantity: number
    unit?: string
  }>
  instructions: string
  meal_type?: string
  prep_time?: number
  cook_time?: number
}

/**
 * RecipeService
 *
 * Business logic layer for recipe operations.
 * Handles data transformation between API DTOs and database models.
 *
 * Similar to Angular services - encapsulates business logic and data access.
 */
export class RecipeService {
  constructor(private supabase: TypedSupabaseClient) {}

  /**
   * Retrieves the household_id for a given user
   *
   * @param userId - The user's UUID
   * @returns The household_id if user is a member, null otherwise
   *
   * TODO: This query will work once households are implemented.
   * For now, returns null which will trigger a 404 response.
   */
  async getUserHouseholdId(userId: string): Promise<string | null> {
    const { data, error } = await this.supabase
      .from('user_households')
      .select('household_id')
      .eq('user_id', userId)
      .single()

    if (error || !data) {
      return null
    }

    return data.household_id
  }

  /**
   * Creates a new recipe with specified creation method
   *
   * @param userId - The user creating the recipe
   * @param input - Validated recipe input from CreateRecipeSchema (includes optional creationMethod)
   * @returns The created Recipe DTO
   * @throws Error if database operation fails
   *
   * Flow:
   * 1. Get user's household_id (or use default for development)
   * 2. Transform input to JSONB format
   * 3. Insert to database with specified creation_method (defaults to 'manual')
   * 4. Transform database response to Recipe DTO
   *
   * Creation Methods:
   * - 'manual': User created recipe from scratch
   * - 'ai_generated': Recipe generated by AI and saved without modifications
   * - 'ai_generated_modified': AI recipe that was edited before saving (future feature)
   *
   * TEMPORARY: Currently uses DEFAULT_HOUSEHOLD_ID as fallback for development.
   * TODO: Once households are implemented, remove the fallback and throw error
   * when user is not a member of any household.
   */
  async createRecipe(userId: string, input: CreateRecipeInput): Promise<Recipe> {
    // Try to get user's household_id from database
    let householdId = await this.getUserHouseholdId(userId)

    // TEMPORARY WORKAROUND: Use default household for single-user development
    // TODO: Remove this fallback once household management is fully implemented
    if (!householdId) {
      console.warn(
        `[RecipeService] User ${userId} has no household. Using DEFAULT_HOUSEHOLD_ID for development.`
      )
      householdId = DEFAULT_HOUSEHOLD_ID
    }

    // Transform API input (camelCase) to database format (snake_case in JSONB)
    const recipeContent: RecipeContent = {
      title: input.title,
      ingredients: input.ingredients,
      instructions: input.instructions,
      ...(input.prepTime !== undefined && { prep_time: input.prepTime }),
      ...(input.cookTime !== undefined && { cook_time: input.cookTime }),
      ...(input.mealType !== undefined && { meal_type: input.mealType }),
    }

    // Insert to database with specified creation_method (defaults to 'manual' via schema)
    const { data, error } = await this.supabase
      .from('recipes')
      .insert({
        household_id: householdId,
        content:
          recipeContent as unknown as Database['public']['Tables']['recipes']['Insert']['content'],
        creation_method: input.creationMethod || 'manual',
      })
      .select()
      .single()

    if (error) {
      console.error('[RecipeService] Database error creating recipe:', error)
      throw new Error('Failed to create recipe')
    }

    // Transform database record to Recipe DTO
    return this.mapDbRecipeToDto(data)
  }

  /**
   * Deletes multiple recipes in a single operation
   *
   * @param userId - The authenticated user's ID
   * @param recipeIds - Array of recipe UUIDs to delete (1-50 items)
   * @returns BulkDeleteRecipesResponse with deleted, failed arrays and summary
   * @throws Error for database errors (never throws for individual recipe failures)
   *
   * Flow:
   * 1. Get user's household_id (with DEFAULT_HOUSEHOLD_ID fallback)
   * 2. For each recipe ID:
   *    a. Verify recipe exists and belongs to user's household
   *    b. If yes → delete and add to 'deleted' array
   *    c. If no → add to 'failed' array with reason
   * 3. Return detailed results with summary
   *
   * Important:
   * - Processes all IDs even if some fail (partial success)
   * - Does NOT use transaction (each delete is independent)
   * - Returns 200 OK even if all deletions fail (check response body)
   * - Maximum 50 recipes per request to prevent abuse
   *
   * Security Pattern:
   * - Same authorization check as single delete
   * - Failed items don't reveal why (could be not found OR no access)
   *
   * Performance Considerations:
   * - Current implementation: N+2 queries (household + N verifications + N deletes)
   * - Optimization possible: Use bulk queries with ANY() operator
   * - Trade-off: Simplicity vs performance (optimize if needed)
   *
   * Why no transaction?
   * - Partial success is desirable (delete what we can)
   * - User gets feedback on what succeeded vs failed
   * - More user-friendly than all-or-nothing approach
   *
   * TEMPORARY: Uses DEFAULT_HOUSEHOLD_ID as fallback for development.
   */
  async bulkDeleteRecipes(userId: string, recipeIds: string[]): Promise<BulkDeleteRecipesResponse> {
    // 1. Get user's household_id (with DEFAULT_HOUSEHOLD_ID fallback)
    let householdId = await this.getUserHouseholdId(userId)

    // TEMPORARY WORKAROUND: Use default household for single-user development
    if (!householdId) {
      console.warn(
        `[RecipeService] User ${userId} has no household. Using DEFAULT_HOUSEHOLD_ID for development.`
      )
      householdId = DEFAULT_HOUSEHOLD_ID
    }

    // 2. Initialize result arrays
    const deleted: string[] = []
    const failed: Array<{ id: string; reason: string }> = []

    // 3. Process each recipe ID
    // Note: We process sequentially for simplicity. Could be optimized with bulk queries.
    for (const recipeId of recipeIds) {
      try {
        // 3a. Verify recipe exists and user has access
        const { data: existingRecipe, error: checkError } = await this.supabase
          .from('recipes')
          .select('id')
          .eq('id', recipeId)
          .eq('household_id', householdId)
          .single()

        if (checkError || !existingRecipe) {
          // Recipe not found or no access
          failed.push({
            id: recipeId,
            reason: 'Recipe not found or no access',
          })
          continue // Move to next recipe
        }

        // 3b. Delete the recipe
        const { error: deleteError } = await this.supabase
          .from('recipes')
          .delete()
          .eq('id', recipeId)
          .eq('household_id', householdId) // Double-check authorization

        if (deleteError) {
          // Database error during deletion
          console.error('[RecipeService] Error deleting recipe in bulk:', {
            recipeId,
            error: deleteError.message,
          })
          failed.push({
            id: recipeId,
            reason: 'Failed to delete',
          })
          continue
        }

        // 3c. Success - add to deleted array
        deleted.push(recipeId)
      } catch (error) {
        // Unexpected error for this specific recipe
        console.error('[RecipeService] Unexpected error in bulk delete:', {
          recipeId,
          error,
        })
        failed.push({
          id: recipeId,
          reason: 'Unexpected error',
        })
      }
    }

    // 4. Return detailed results
    return {
      deleted,
      failed,
      summary: {
        total: recipeIds.length,
        successful: deleted.length,
        failed: failed.length,
      },
    }
  }

  /**
   * Deletes a recipe permanently
   *
   * @param userId - The authenticated user's ID
   * @param recipeId - The recipe UUID to delete
   * @returns void (Promise<void>)
   * @throws Error with message 'Recipe not found' if recipe doesn't exist or user has no access
   * @throws Error for other database errors
   *
   * Flow:
   * 1. Get user's household_id (with DEFAULT_HOUSEHOLD_ID fallback)
   * 2. Verify recipe exists and user has access (same pattern as update)
   * 3. Delete recipe from database
   * 4. No return value (void)
   *
   * Security Pattern:
   * - Same authorization check as getRecipeById and updateRecipe
   * - Returns "Recipe not found" for unauthorized access
   * - Verification step prevents accidental deletion
   *
   * Important:
   * - This is a HARD DELETE (permanent)
   * - CASCADE constraints in DB may delete related data
   * - For soft delete, use updated_at or deleted_at field instead
   *
   * TEMPORARY: Uses DEFAULT_HOUSEHOLD_ID as fallback for development.
   */
  async deleteRecipe(userId: string, recipeId: string): Promise<void> {
    // 1. Get user's household_id (with DEFAULT_HOUSEHOLD_ID fallback)
    let householdId = await this.getUserHouseholdId(userId)

    // TEMPORARY WORKAROUND: Use default household for single-user development
    // TODO: Remove this fallback once household management is fully implemented
    if (!householdId) {
      console.warn(
        `[RecipeService] User ${userId} has no household. Using DEFAULT_HOUSEHOLD_ID for development.`
      )
      householdId = DEFAULT_HOUSEHOLD_ID
    }

    // 2. First, verify the recipe exists and user has access
    // This prevents deleting non-existent recipes or recipes from other households
    const { data: existingRecipe, error: checkError } = await this.supabase
      .from('recipes')
      .select('id')
      .eq('id', recipeId)
      .eq('household_id', householdId)
      .single()

    if (checkError || !existingRecipe) {
      if (checkError) {
        console.error('[RecipeService] Error verifying recipe access:', {
          recipeId,
          userId,
          error: checkError.message,
        })
      }
      throw new Error('Recipe not found')
    }

    // 3. Delete the recipe
    // Using the same filters for defense in depth
    const { error } = await this.supabase
      .from('recipes')
      .delete()
      .eq('id', recipeId)
      .eq('household_id', householdId) // Double-check authorization

    if (error) {
      console.error('[RecipeService] Database error deleting recipe:', error)
      throw new Error('Failed to delete recipe')
    }

    // 4. No return value - void
    // Frontend knows deletion succeeded by HTTP 204 status
  }

  /**
   * Updates an existing recipe with new content
   *
   * @param userId - The authenticated user's ID
   * @param recipeId - The recipe UUID to update
   * @param input - Validated recipe input from CreateRecipeSchema
   * @returns Updated Recipe DTO
   * @throws Error with message 'Recipe not found' if recipe doesn't exist or user has no access
   * @throws Error for other database errors
   *
   * Flow:
   * 1. Get user's household_id (with DEFAULT_HOUSEHOLD_ID fallback)
   * 2. Verify recipe exists and user has access (same as getRecipeById)
   * 3. Transform input to JSONB format (camelCase → snake_case)
   * 4. Update only the 'content' field in database
   * 5. Transform updated record to Recipe DTO
   *
   * Important:
   * - Only updates the 'content' JSONB field
   * - Does NOT update: household_id, creation_method, id
   * - updated_at is automatically set by database trigger
   *
   * Security Pattern:
   * - Uses same authorization check as getRecipeById
   * - Returns "Recipe not found" for unauthorized access
   *
   * Similar to Angular's FormGroup.patchValue() - updates only specified fields.
   *
   * TEMPORARY: Uses DEFAULT_HOUSEHOLD_ID as fallback for development.
   */
  async updateRecipe(userId: string, recipeId: string, input: CreateRecipeInput): Promise<Recipe> {
    // 1. Get user's household_id (with DEFAULT_HOUSEHOLD_ID fallback)
    let householdId = await this.getUserHouseholdId(userId)

    // TEMPORARY WORKAROUND: Use default household for single-user development
    // TODO: Remove this fallback once household management is fully implemented
    if (!householdId) {
      console.warn(
        `[RecipeService] User ${userId} has no household. Using DEFAULT_HOUSEHOLD_ID for development.`
      )
      householdId = DEFAULT_HOUSEHOLD_ID
    }

    // 2. First, verify the recipe exists and user has access
    // This prevents updating non-existent recipes or recipes from other households
    const { data: existingRecipe, error: checkError } = await this.supabase
      .from('recipes')
      .select('id')
      .eq('id', recipeId)
      .eq('household_id', householdId)
      .single()

    if (checkError || !existingRecipe) {
      if (checkError) {
        console.error('[RecipeService] Error verifying recipe access:', {
          recipeId,
          userId,
          error: checkError.message,
        })
      }
      throw new Error('Recipe not found')
    }

    // 3. Transform API input (camelCase) to database format (snake_case in JSONB)
    const recipeContent: RecipeContent = {
      title: input.title,
      ingredients: input.ingredients,
      instructions: input.instructions,
      ...(input.prepTime !== undefined && { prep_time: input.prepTime }),
      ...(input.cookTime !== undefined && { cook_time: input.cookTime }),
      ...(input.mealType !== undefined && { meal_type: input.mealType }),
    }

    // 4. Update the recipe (only content field, updated_at is auto-updated by trigger)
    const { data, error } = await this.supabase
      .from('recipes')
      .update({
        content:
          recipeContent as unknown as Database['public']['Tables']['recipes']['Update']['content'],
      })
      .eq('id', recipeId)
      .eq('household_id', householdId) // Double-check authorization
      .select()
      .single()

    if (error || !data) {
      console.error('[RecipeService] Database error updating recipe:', error)
      throw new Error('Failed to update recipe')
    }

    // 5. Transform updated record to DTO
    return this.mapDbRecipeToDto(data)
  }

  /**
   * Retrieves a single recipe by ID with authorization check
   *
   * @param userId - The authenticated user's ID
   * @param recipeId - The recipe UUID to retrieve
   * @returns Recipe DTO if found and authorized
   * @throws Error with message 'Recipe not found' if recipe doesn't exist or user has no access
   * @throws Error for other database errors
   *
   * Flow:
   * 1. Get user's household_id (with DEFAULT_HOUSEHOLD_ID fallback)
   * 2. Query recipe with both id AND household_id filters
   * 3. If no result → user either doesn't have access OR recipe doesn't exist
   * 4. Transform database record to Recipe DTO
   *
   * Security Pattern:
   * - We use "Recipe not found" for both cases (not exists + no access)
   * - This prevents leaking information about existence of other users' recipes
   * - Similar to how Angular guards can return false without revealing why
   *
   * TEMPORARY: Uses DEFAULT_HOUSEHOLD_ID as fallback for development.
   */
  async getRecipeById(userId: string, recipeId: string): Promise<Recipe> {
    // 1. Get user's household_id (with DEFAULT_HOUSEHOLD_ID fallback)
    let householdId = await this.getUserHouseholdId(userId)

    // TEMPORARY WORKAROUND: Use default household for single-user development
    // TODO: Remove this fallback once household management is fully implemented
    if (!householdId) {
      console.warn(
        `[RecipeService] User ${userId} has no household. Using DEFAULT_HOUSEHOLD_ID for development.`
      )
      householdId = DEFAULT_HOUSEHOLD_ID
    }

    // 2. Query recipe with BOTH id and household_id
    // This ensures authorization in a single query - efficient and secure
    const { data, error } = await this.supabase
      .from('recipes')
      .select('*')
      .eq('id', recipeId)
      .eq('household_id', householdId)
      .single()

    // 3. Handle errors and missing data
    if (error || !data) {
      // Log for debugging, but don't expose details to caller
      if (error) {
        console.error('[RecipeService] Error fetching recipe:', {
          recipeId,
          userId,
          error: error.message,
        })
      }

      // Generic error message for security (404 will be set in route handler)
      throw new Error('Recipe not found')
    }

    // 4. Transform to DTO using existing mapper
    return this.mapDbRecipeToDto(data)
  }

  /**
   * Lists recipes for a user's household with filtering and pagination
   *
   * @param userId - The authenticated user's ID
   * @param filters - Filter, sort, and pagination options
   * @returns Paginated list of recipes with metadata
   * @throws Error if database operation fails
   *
   * Flow:
   * 1. Get user's household_id (with DEFAULT_HOUSEHOLD_ID fallback)
   * 2. Build Supabase query with filters
   * 3. Apply search filter (full-text on JSONB)
   * 4. Apply mealType and creationMethod filters
   * 5. Apply sorting (handle title in JSONB separately)
   * 6. Apply pagination (range)
   * 7. Execute query with count
   * 8. Transform database records to Recipe DTOs
   *
   * Similar to Angular's service pattern - encapsulates complex query logic.
   *
   * TEMPORARY: Uses DEFAULT_HOUSEHOLD_ID as fallback for development.
   * TODO: Once households are implemented, consider returning error
   * when user is not a member of any household.
   */
  async listRecipes(
    userId: string,
    filters: RecipeFilters
  ): Promise<{ data: Recipe[]; pagination: Pagination }> {
    // 1. Get household_id (with DEFAULT_HOUSEHOLD_ID fallback)
    let householdId = await this.getUserHouseholdId(userId)

    // TEMPORARY WORKAROUND: Use default household for single-user development
    // TODO: Remove this fallback once household management is fully implemented
    if (!householdId) {
      console.warn(
        `[RecipeService] User ${userId} has no household. Using DEFAULT_HOUSEHOLD_ID for development.`
      )
      householdId = DEFAULT_HOUSEHOLD_ID
    }

    // 2. Build base query
    let query = this.supabase
      .from('recipes')
      .select('*', { count: 'exact' })
      .eq('household_id', householdId)

    // 3. Apply search filter (case-insensitive search in recipe title)
    if (filters.search) {
      // Search in title field within JSONB content
      // Use ilike for case-insensitive pattern matching
      query = query.ilike('content->>title', `%${filters.search}%`)
    }

    // 4. Apply mealType filter
    if (filters.mealType) {
      // Use ->> to extract text value from JSONB for comparison
      query = query.eq('content->>meal_type', filters.mealType)
    }

    // 5. Apply creationMethod filter
    if (filters.creationMethod) {
      query = query.eq(
        'creation_method',
        filters.creationMethod as 'manual' | 'ai_generated' | 'ai_generated_modified'
      )
    }

    // 6. Apply sorting
    const ascending = filters.sortDirection === 'asc'

    if (filters.sortField === 'title') {
      // Title is in JSONB content - use ->> to extract text value
      query = query.order('content->>title', { ascending })
    } else {
      // created_at, updated_at are direct columns
      query = query.order(filters.sortField, { ascending })
    }

    // 7. Apply pagination
    const from = (filters.page - 1) * filters.pageSize
    const to = from + filters.pageSize - 1
    query = query.range(from, to)

    // 8. Execute query
    const { data, error, count } = await query

    if (error) {
      console.error('[RecipeService] Error listing recipes:', error)
      throw new Error('Failed to fetch recipes')
    }

    // 9. Transform to DTOs using existing method
    const recipes = data?.map(record => this.mapDbRecipeToDto(record)) || []

    // 10. Return with pagination metadata
    return {
      data: recipes,
      pagination: {
        page: filters.page,
        pageSize: filters.pageSize,
        total: count || 0,
      },
    }
  }

  /**
   * Maps database recipe record to Recipe DTO
   *
   * Transforms:
   * - JSONB content field to flat structure
   * - snake_case to camelCase
   * - Database types to DTO types
   *
   * @param dbRecipe - Recipe record from database
   * @returns Recipe DTO for API response
   *
   * @private
   */
  private mapDbRecipeToDto(dbRecipe: Database['public']['Tables']['recipes']['Row']): Recipe {
    // Parse JSONB content
    const content = dbRecipe.content as unknown as RecipeContent

    return {
      id: dbRecipe.id,
      title: content.title,
      ingredients: content.ingredients,
      instructions: content.instructions,
      creationMethod: dbRecipe.creation_method,
      prepTime: content.prep_time,
      cookTime: content.cook_time,
      mealType: content.meal_type,
      createdAt: dbRecipe.created_at,
      updatedAt: dbRecipe.updated_at,
      householdId: dbRecipe.household_id,
    }
  }
}
